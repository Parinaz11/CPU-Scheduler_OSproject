این برنامه با استفاده از الگوریتم های (FCFS,SJF,RR) یک سیستم زمان بندی وظایف اولیه را شبیه سازی می کند. این برنامه یک کلاس "Task" را با ویژگی هایی مانند نام، نوع، مدت زمان، منابع، وضعیت، زمان اجرا و اولویت تعریف می کند. منطق زمان‌بندی با استفاده از الگوریتم ها ذکر شده در تابع مشخص پیاده‌سازی می‌شود، که اجرای وظایف را از طریق رشته‌هایی که برای هر پردازنده طراحی شده، مدیریت می‌کند و با استفاده از قفل ها همگام سازی میان نخ ها صورت میگیرد. تابع اصلی ورودی کاربر را برای منابع و وظایف جمع آوری می کند، وظایف را مقداردهی اولیه می کند و آنها را به یک صف آماده اضافه می کند. یک رشته چاپی به طور همزمان نتایج اجرا را نمایش می دهد. الگوریتم ها ذکر شده اجرای کار را شبیه سازی می کند و برنامه با چاپ نتایج نهایی به پایان می رسد. همچنین می‌توان تعداد پردازنده ها و سایر پارامترها را برای مطابقت با پیکربندی‌های خاص سیستم انجام داد.


الگوریتم SJF:

در فایل SJF.py با استفاده از resource allocation و aging، پیاده سازی SJF را شبیه سازی کردیم. به دلیل استفاده از الگوریتم SJF، اولویت پراسس هارا duration و مدت زمانشان قرار میدهیم. در این برنامه هر thread نمایانگر یک core میباشد که یک تسک را انجام میدهد.
در این برنامه پس از دریافت ورودی برای هر تسک، شی از کلاس Task برای آن ایجاد میکنیم که شامل ویژگی هایی از جمله اسم، نوع تسک، منابع مورد نیاز آن، اولویت و ... میباشد. core ها را با kernel_threads که یک لیست میباشد نشان میدهیم و ترد دیگری برای چاپ خروجی تعریف میکنیم. سپس ترد های کرنل را start کرده و به دنبال آن ترد چاپ خروجی را آغاز میکنیم. برنامه پس از جوین شدن تمام ترد ها داخل حلقه تمام میشود. تسکی که هر ترد انجام میدهد به این صورت است که ابندا exit_event را برای set() نبودنش چک میکند (به این معنی که برنامه تمام نشده). و داخل این حلقه تسکی را از صف ready برداشته و منابع آن را بررسی میکند. اگر این منابع در دسترس نباشد، این تسک از حالت running خارج شده و وارد حالت waiting میشود و در صف waiting قرار داده میشود. در این بخش برای جلوگیری از وقوع starvation نیز چک میکنیم که اگر تعداد دفعاتی که این تسک در حالت انتظار رفته بیش از سه باشد، به اولویت آن یکی اضافه میشود. در نهایت پس از اینکه یک core، تسک را انجام داد، منابعی که allocate شده بودند آزاد میشوند. در اگر هر چهار core در حال انجام تسک باشد داخل یک timeUnit، آنگاه event برای پرینت set میشود و ترد print_results که منتظر این event بود برای چاپ خروجی فعال میشود.
